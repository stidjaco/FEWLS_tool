######################################################################################
#  ____        _              _____ _______        ___     ____    _____           _ #
# / ___|  ___ | | __ _ _ __  |  ___| ____\ \      / / |   / ___|  |_   _|__   ___ | |#
# \___ \ / _ \| |/ _` | '__| | |_  |  _|  \ \ /\ / /| |   \___ \    | |/ _ \ / _ \| |#
#  ___) | (_) | | (_| | |    |  _| | |___  \ V  V / | |___ ___) |   | | (_) | (_) | |#
# |____/ \___/|_|\__,_|_|    |_|   |_____|  \_/\_/  |_____|____/    |_|\___/ \___/|_|#
#                                                                                    #
######################################################################################

## De"script"tion
"
This is an optional file (no directly used in FEWLS model, but the data generated is 
essential for diserning inputs to the FEWLS model) that generates that outputs three 
dataframes and fig described here: 

- SolarFEWE_generation_input.csv: Dataframe containing the system index, panel area, 
mount class, installation year, pvlib modeled annual electricity generated by the solar 
array (MWh/yr)

- SolarFEWE_econ_inputs.csv: Dataframe containing the system index, panel area, mount 
class, installation year, and the estimated monthly load for the farm associated with 
each array (MWh/month) -- this is distributed by the load profiles we had discussed. 

- SolarFEWE_LoadDF_annual.csv: Dataframe containing three rows for each installation
delineating annual load, deficit, and surplus generation of each array (MWh).  

- ag_electricityDemand_profile.pdf: Triple-plot of agricultural demand profiles for
irrigation, non-irrigated, and the hourly proportion of annual load.

- Surplus_Deficits##LS_##MW.pdf: Dual sub-plot figure with (top) local-per-array 
average proportion of annual load met [%] and (bottom) regional surplus and deficit 
energy [GWh] for irrigated [blue] and non-irrigated [brown] installations.
"

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Run the funciton compile in FEWLS_model.R to generate annual load vs surplus figure

# Get in_df which is less than capacity threshold
in_df <- in_solar_df[which(in_solar_df$Capacity<capacity_threshold), ]

# Essential graphs for manuscript
getFarmElec_Budget(in_df[which(in_df$Capacity<capacity_threshold), ])

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Get Utility Information

# GET UTLITY AND LAT LONG DATA
# California Electric Utilitys 
sf_use_s2(FALSE)
# Data source: https://gis.data.ca.gov/datasets/b95ca182aa254c3db8ad4d92bd32a73c_0?geometry=-161.087%2C31.071%2C-77.459%2C43.276
CA_utility <- st_read('Data/Downloaded/CA_UtilService_shp/California_Electric_Utility_Service_Areas.shp') %>%
  st_transform(crs = st_crs(4326)) %>%
  st_buffer(dist = 0) %>%
  st_make_valid()
#st_intersection(CV_Boundary)
#st_difference() # overlapping?
CA_utility$Utility <- CA_utility$Utility %>% as.character()
# Get bounds for Sid
CA_utility$lon_min = NA
CA_utility$lon_max = NA
CA_utility$lat_min = NA
CA_utility$lat_max = NA
for (i in 1:nrow(CA_utility)){
  CA_utility[i, ]$lon_min <- st_bbox(CA_utility[i, ]$geometry)[1] %>% as.numeric()
  CA_utility[i, ]$lat_min <- st_bbox(CA_utility[i, ]$geometry)[2] %>% as.numeric()
  CA_utility[i, ]$lon_max <- st_bbox(CA_utility[i, ]$geometry)[3] %>% as.numeric()
  CA_utility[i, ]$lat_max <- st_bbox(CA_utility[i, ]$geometry)[4] %>% as.numeric()
}
# Intersect and Group shapes by utility 
# Had to do for loop because of st_intersection multipolygon error
df <- data.frame(ID=character(), Utility=character())
namesdf <- names(df)
for(i in 1:nrow(in_df)){
  centroid <- st_centroid(in_df[i, ])
  Utility <- st_intersection(CA_utility, centroid)
  idata <- t(data.frame(c(0, 0)))
  idata[1] <- i
  idata[2] <- Utility$Utility
  idata <- data.frame(idata)
  row.names(idata) <- i
  names(idata) <- namesdf
  names(df) <- namesdf
  df <- rbind(df, idata)
  print(paste('Completed ', i))
}
in_df$Utility <- df$Utility
rm(df, i, namesdf, Utility, idata, centroid)


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Export dataset info for histical electricity rate acquisition and modeling (Lat, Long, Bopt, PF, PFopt) -- code from Stid et al., 2022

### Get packing factor, optimal packing factor, and optimal tilt angle (Martín-Chivelet, 2016) -- https://doi.org/10.1016/j.energy.2015.10.108

# Get centroids (for lat long)
centroids <- st_centroid(in_df)
coords <- as.data.frame(st_coordinates(centroids$geometry))
in_df$Lat <- coords$Y
in_df$Long <- coords$X

# Actual Packing Factor
in_df$PF <- in_df$pnl_a/in_df$dir_a

# Optimum packing factor PF_0 represents the packing factor at 0 degrees latitude (depending on shading criterion), and A and B area fitted parameters of quadratic dependence of packing factor in percentage with latitude. Assumption of tilt optimized for maximum yearly production (Martín-Chivelet, 2016) latitude in GCS WGS 1984, EPSG:4326
PF_0_fixed <- 100
PF_0_single <- 91.5
A <- 0.0100
B <- 0.8366
in_df$PFopt <- ifelse(in_df$Class=='fixed_axis', ((PF_0_fixed - (A*in_df$Lat^2) - (B*in_df$Lat)) / 100), ((PF_0_single - (A*in_df$Lat^2) - (B*in_df$Lat)) / 100)) # in this case, we only consider fixed and single axis, so "else" is single-axis

# Calculate Single Axis Packing Facotr Potential Deviation: Range in panel area given NAIP fly time occurs between 10am and 2pm
# Based on NOAA solar calculator, and max -45 to 45 degree tilt from https://www.lfb.rwth-aachen.de/bibtexupload/pdf/DS12a.pdf (Schneider, 2012)
Min_angle <- 0
Max_angle <- 45
Min_time <- 06.66667
Max_time <- 13.16667
NAIP_time <- 10
MaxTilt_slope <- (Max_angle - Min_angle) / (Max_time - Min_time)
MaxTilt_yint <- -1*(MaxTilt_slope * Max_time)
MaxTilt <- as.numeric(abs(MaxTilt_slope * NAIP_time + MaxTilt_yint))
in_df$PF_ptdv <- ifelse(in_df$Class=='single_axis', (in_df$pnl_a / cos(MaxTilt * pi / 180) / in_df$dir_a), NA) # Large possible panel area if overhead aerial imagery was taken when panel at 45 degrees (tighter packing factor)

# Packing factor Deviation (with range for tracking axis potential deviation)
in_df$PFdiff <- in_df$PF - in_df$PFopt
in_df$PFdff_p <- in_df$PF_ptdv - in_df$PFopt

# Optimal fixed-axis tilt (tiltA and tiltB are polynomial coefficients for equation 20 in (Martín-Chivelet, 2016) -- https://doi.org/10.1016/j.energy.2015.10.108)
tiltA = -0.0049
tiltB = 1.0888
in_df$Bopt <- ifelse(in_df$Class=='fixed_axis', tiltA * in_df$Lat^2 + tiltB * in_df$Lat, 0) # result is in degrees

# Write solarFEWE_generation_input.csv (all arrays, dont subselect for commercial)
in_df_temp <- in_df
in_df_temp$geometry = NULL
in_df_temp <- in_df_temp %>% dplyr::select(matches("Index|Gen|Year|pnl_a|Class|dir_a|Lat|Long|Bopt|PF|PFopt|PFdiff|PF_ptdv|Utility|Capacity")) # necessary for electricity rate analysis input: Index|Gen|Year|pnl_a|Class|Bopt|
write.csv(in_df_temp, "Data/Derived/SolarFEWE_generation_input.csv", row.names=FALSE)


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BUILDING Proportion matrix to multiply annual farm load by to distribute across the year


### BUILDING Proportion matrix to multiply annual farm load by to distribute across the year

# Set initial variables
L = 1 # 1% monthly use baseline - intercept that creates base level of annual use that scales towards summer and away from winter (based on oleson et al 2014)
peak_month = 7 # July is peak month (based on oleson et al 2014)

# Get h (max proportion of annual load in peak month)
b1 = (peak_month - 1) # - 1 is becuase of zero indexing (July is now the 6th month) -- b1 is base length 1 in geometry assessment
non_baseload_ar = 100 - (L * 11) # 100% initial area minus areal proportion created by baseload -- 11 is distance of zero index year 
h = (non_baseload_ar * 2) / 11 # Generates rectangle, finds height 
slope1 = h / (b1) 
slope2 = h / (11-b1) 

# Build initial df with zero load
df <- data.frame(Month = c(0:11), load = rep(0,12))
df$load = ifelse(df$Month<b1, slope1 * df$Month + L, -slope2 * (df$Month - b1) + L + h)
df$Month = df$Month + 1 # Return to month base 1 index
df$load = df$load / 100 # return to proportion
#plot(df$Month, df$load)
sum(df$load)

# if any deviation from 1, subtract or add deviation to peak month. This is a minute deviation from rounding errors
anndf = df
dev = 1 - sum(anndf$load)
anndf$load <- ifelse(anndf$Month==peak_month, anndf$load+dev, anndf$load)
sum(anndf$load) # should = 1

# hourly profile
hourly = rep(1/24, 24)

# Generate agricultural electricitiy demand profile
Jan = anndf$load[1] * hourly
Feb = anndf$load[2] * hourly
Mar = anndf$load[3] * hourly
Apr = anndf$load[4] * hourly
May = anndf$load[5] * hourly
Jun = anndf$load[6] * hourly
Jul = anndf$load[7] * hourly
Aug = anndf$load[8] * hourly
Sep = anndf$load[9] * hourly
Oct = anndf$load[10] * hourly
Nov = anndf$load[11] * hourly
Dec = anndf$load[12] * hourly
df <- data.frame(Jan = Jan, Feb = Feb, Mar = Mar, Apr = Apr, May = May, Jun = Jun, Jul = Jul, Aug = Aug, Sep = Sep, Oct = Oct, Nov = Nov, Dec = Dec)
df_save = df

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Generate Figures

# Change to raster
df <- df %>%
  rownames_to_column() %>%
  gather(colname, value, -rowname)
# Change month names to numbers 
df$colname = ifelse(df$colname=="Jan", 1, 
             ifelse(df$colname=="Feb", 2, 
             ifelse(df$colname=="Mar", 3, 
             ifelse(df$colname=="Apr", 4, 
             ifelse(df$colname=="May", 5, 
             ifelse(df$colname=="Jun", 6, 
             ifelse(df$colname=="Jul", 7, 
             ifelse(df$colname=="Aug", 8, 
             ifelse(df$colname=="Sep", 9, 
             ifelse(df$colname=="Oct", 10, 
             ifelse(df$colname=="Nov", 11, 
             ifelse(df$colname=="Dec", 12, 0))))))))))))
df$rowname <- df$rowname %>% as.numeric()
df$colname <- df$colname %>% as.numeric()
df$value <- df$value %>% as.numeric()
range(df$value)

# Start with just proportion fig
df_prop <- df
df_prop$value = df_prop$value * 100
plot_prop_agload <- ggplot(df, aes(x = rowname, y = colname, fill = value)) +
  geom_tile() +
  ylab("Month") + 
  xlab("Hour") + 
  scale_y_continuous(breaks=seq(0, 12, 2), limits = c(0.5, 12.5), expand = c(0,0)) +
  scale_x_continuous(breaks=seq(0, 24, 3), limits = c(0.5,24.5), expand = c(0,0)) + 
  scale_fill_gradient("Prop. Annual Load", low="green", high="red") +
  theme_bw()
# Multiply df by farm annual requirements
df_irrig <- df
df_irrig$value = df_irrig$value * 422000 # 422000 for irrig, 91000 for non irrig, 1 for props
plot_irrig_agload <- ggplot(df_irrig, aes(x = rowname, y = colname, fill = value)) +
  geom_tile() +
  ylab("Month") + 
  xlab("Hour") + 
  scale_y_continuous(breaks=seq(0, 12, 2), limits = c(0.5, 12.5), expand = c(0,0)) +
  scale_x_continuous(breaks=seq(0, 24, 3), limits = c(0.5,24.5), expand = c(0,0)) + 
  scale_fill_gradient("Irrig Farm Profile", low="green", high="red") +
  theme_bw()
# Multiply df by farm annual requirements
df_nonir <- df
df_nonir$value = df_nonir$value * 91000 # 422000 for irrig, 91000 for non irrig, 1 for props
plot_nonir_agload <- ggplot(df_nonir, aes(x = rowname, y = colname, fill = value)) +
  geom_tile() +
  ylab("Month") + 
  xlab("Hour") + 
  scale_y_continuous(breaks=seq(0, 12, 2), limits = c(0.5, 12.5), expand = c(0,0)) +
  scale_x_continuous(breaks=seq(0, 24, 3), limits = c(0.5,24.5), expand = c(0,0)) + 
  scale_fill_gradient("NonIr Farm Profile", low="green", high="red") +
  theme_bw()
ggarrange(plot_prop_agload, plot_irrig_agload, plot_nonir_agload, nrow = 3, ncol = 1, align = c("hv"))
ggsave("ag_electricityDemand_profile.pdf", width = 3.5, height = 6)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Get load profiel data for each array to sid

# Regroup and prepare dataframe for Sid
df_month = colSums(df_save) %>% as.data.frame() %>% t() %>% as.data.frame()

# Get array-farm annual electricity recs
#capacity_threshold = 100000000 # set arbitrary cutoff for all arrays -- subsets for commerical but going to have all for scenarios
load_df <- getResource_annFarmOperationReq(in_df)
write.csv(load_df, "Data/Derived/SolarFEWE_LoadDf_annual.csv", row.names=FALSE)
load_df <- load_df %>% group_by(Index) %>% summarise(ann_operation_MWh = mean(ann_operation_MWh), Year = first(Year)) # mean finds the average farm reqs through years. The first year we report is the year of installation

# Prep and merge month proportion df with load df
df_month[2:nrow(load_df), ] <- df_month[1, ]
load_df <- cbind(load_df, df_month)

# Distribute annual load across year
load_df[, 4:ncol(load_df)] <- load_df$ann_operation_MWh * load_df[, 4:ncol(load_df),]
rownames(load_df) <- c(1:nrow(load_df))

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Get average rate of electricity in 2018

# Get centroids
in_df_temp <- in_df[which(in_df$Capacity<capacity_threshold), ]
centroids <- st_centroid(in_df_temp)
coords <- as.data.frame(st_coordinates(centroids$geometry))
centroids$Lat <- coords$Y
centroids$Long <- coords$X

# /////////////////////////////////////

# Get and merge all other necessary attributes
load_df$Lat <- centroids$Lat[match(load_df$Index, centroids$Index)]
load_df$Long <- centroids$Long[match(load_df$Index, centroids$Index)]
load_df$Utility <- in_df_temp$Utility[match(load_df$Index, in_df_temp$Index)]
load_df$Class <- in_df_temp$Class[match(load_df$Index, in_df_temp$Index)]
load_df$pnl_a <- in_df_temp$pnl_a[match(load_df$Index, in_df_temp$Index)]
load_df$ann_operation_MWh = NULL
write.csv(load_df, "Data/Derived/SolarFEWE_econ_inputs.csv", row.names=FALSE)